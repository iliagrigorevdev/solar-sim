#version 300 es
#extension GL_OES_standard_derivatives : enable
precision highp float;

out vec4 out_color;

uniform float u_min_radius;
uniform float u_max_radius;

in float v_radius;

// Функция для отображения радиуса в цвет (фиолетовый-синий-зеленый-желтый-красный)
vec3 radiusToColor(float radius) {
    // The radius can be from u_min_radius to u_max_radius. We use a logarithmic scale.
    float log_radius = log(radius);
    // Normalize log_radius from [log(u_min_radius), log(u_max_radius)] to [0, 1]
    float log_min = log(u_min_radius);
    float log_max = log(u_max_radius);
    float t = (log_radius - log_min) / (log_max - log_min);
    t = clamp(t, 0.0, 1.0);

    vec3 violet = vec3(0.6, 0.2, 1.0);
    vec3 blue = vec3(0.2, 0.5, 1.0);
    vec3 yellow = vec3(1.0, 0.9, 0.2);
    vec3 red = vec3(1.0, 0.3, 0.2);

    if (t < 0.5) {
        return mix(violet, blue, t * 2.0);
    } else if (t < 0.75) {
        return mix(blue, yellow, (t - 0.5) * 4.0);
    } else {
        return mix(yellow, red, (t - 0.75) * 4.0);
    }
}

void main() {
    float dist = length(gl_PointCoord - vec2(0.5));
    float edge_width = fwidth(dist);
    float alpha = 1.0 - smoothstep(0.5 - edge_width, 0.5, dist);

    if (alpha <= 0.0) {
        discard;
    }

    vec3 color = radiusToColor(v_radius);
    out_color = vec4(color, alpha);
}
#version 300 es

in vec2 a_body_pos;
in float a_body_radius;

uniform float u_initialization_radius;
uniform vec2 u_resolution;
uniform float u_zoom;

out float v_radius;

void main() {
    float resolution = min(u_resolution.x, u_resolution.y);
    vec2 scaled_pos = a_body_pos / u_initialization_radius;
    
    vec2 aspect_ratio_correction = u_resolution.x > u_resolution.y ? vec2(u_resolution.y / u_resolution.x, 1.0) : vec2(1.0, u_resolution.x / u_resolution.y);
    
    gl_Position = vec4(scaled_pos * aspect_ratio_correction * u_zoom, 0.0, 1.0);
    gl_PointSize = max(a_body_radius / u_initialization_radius * resolution * u_zoom, 2.0);
    v_radius = a_body_radius;
}
